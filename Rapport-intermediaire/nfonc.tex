\chapter{Besoins non fonctionnels}

\paragraph{}
	En premier lieu, notre domaine d'action se porte sur tout appareil mobile sous Android; par extension notre hypothèse sera testée sur des ordinateurs.
\paragraph{}
	Nous n'avons aucune fiabilité sur la réussite de notre projet, en effet étant un domaine de recherche, le but est d'analyser l'hypothèse et le comportement, énoncé précédemment.

\subsection*{Les algorithmes implémentés :\\}

\begin{itemize}
	\item{\textbf{Bassin versant\footnote{Cf: défénition trouvée sur Wikipédia, \url{http://fr.wikipedia.org/wiki/Bassin_versant}} :} Un bassin versant1 ou bassin-versant est une aire délimitée par des lignes de partage des eaux, à l'intérieur des quelles toutes les eaux tombées alimentent un même exutoire : cours d'eau, lac, mer, océan, etc. Une ligne de partage des eaux ce confond très souvent avec une ligne de crête.\\

	Chaque bassin versant se subdivise en un certain nombre de bassins élémentaires (parfois appelés « sous-bassin versant ») correspondant à la surface d'alimentation des affluents se jetant dans le cours d'eau principal.\\}

	\item{\textbf{Multiplication matricielle\footnote{Cf: défénition trouvé sur Wikipédia, \url{http://fr.wikipedia.org/wiki/Multiplication_matricielle} :}} Il s'agit de la façon la plus fréquente de multiplier des matrices entre elles.\\
	En algèbre linéaire, une matrice A de dimensions m lignes et n colonnes (matrice m×n) représente une application linéaire f d'un espace de dimension n vers un espace de dimension m. Une matrice colonne V de n lignes est une matrice n×1, et représente un vecteur v d'un espace vectoriel de dimension n. Le produit A×V représente f(v).\\
	Si A et B représentent respectivement les applications linéaires f et g, alors A×B représente la composition des applications fog.\\
	Cette opération est utilisée notamment en mécanique lors des calculs de torseur statique, ou en informatique pour la matrice d'adjacence d'un graphe. \\
	Le produit de deux matrices ne peut se définir que si le nombre de colonnes de la première matrice est le même que le nombre de lignes de la deuxième matrice, c'est-à-dire lorsqu'elles sont de type compatible. \\}

	\newpage
	\item{ \textbf{Pi\footnote{Cf: défénition trouvé sur Wikipédia, \url{http://fr.wikipedia.org/wiki/Pi#Approximation_de_.CF.80} :}} On peut trouver une valeur approchée de π de façon empirique, en traçant un cercle, puis en mesurant son diamètre et sa circonférence, puis en divisant la circonférence par le diamètre. Une autre approche géométrique, attribuée à Archimède, consiste à calculer le périmètre Pn d’un polygone régulier à n côtés et à mesurer le diamètre d de son cercle circonscrit, ou celui de son cercle inscrit. Plus le nombre de côtés du polygone est grand, meilleure est la précision obtenue pour la valeur de pi.\\
	Archimède a utilisé cette approche en comparant les résultats obtenus par la formule en utilisant deux polygones réguliers ayant le même nombre de côtés, pour lesquels le cercle est pour l’un circonscrit et pour l’autre inscrit. Il a réussi, avec un polygone à 96 côtés, à déterminer que 3 + 10/71 < pi < 3 + 1/7.\\
	On peut également obtenir des valeurs approchées de pi en mettant en œuvre des méthodes plus modernes. La plupart des formules utilisées pour calculer pi se basent sur la trigonométrie et le calcul intégral. Cependant, certaines sont particulièrement simples, comme la formule de Leibniz. \\}

	\item{ \textbf{Histogramme :} l’histogramme représente la distribution des intensités d'une matrice.}
	\end{itemize}

	\subsection*{langage d'implémentation :}
		Pour effectuer nos tests nous avons opté pour écrire un code natif, c'est-à-dire du C/C++ pour que le code soit portable autant sur appareils mobile que sur nos ordinateurs, en changeant un minimum l'implémentation. 

	\subsection*{tests de validation :}
		Nous ne pouvons pas réellement prévoir de tests de validation, étant donné que nous ne savons pas encore quel genre de résultat nous allons obtenir; nous ne pourrons seulement valider nos tests que s'ils convergent vers le même résultat. 

	\subsection*{description des problèmes associés :}
		Le parallélisme induit des modifications d'algorithme pour que le calcul soit efficace, ce qui nous oblige à penser les algorithmes différemment de ce dont nous avons l'habitude.
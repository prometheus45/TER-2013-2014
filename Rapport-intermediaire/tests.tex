\chapter{Résultats de tests}

\paragraph{Les outils / Code parallèle \\}

	Il n'existe pas beaucoup d'outils pour paralléliser du code. Nous avons dû faire une recherche sur ce qui existe et utilisable sur Android (cf : 5-Besoins fonctionnels). \\

	Pour obtenir des gains de performance nous nous sommes penchés sur les librairies de parallèlisme classique. Parmi celles ci nos tests ont montrés qu'il était possible d'utiliser des technologies comme les Threads C++11, OpenMP et NEON\footnote{L'ARM NEON également appelé Advanced SIMD ou encore « MPE » (de l'anglais media processing engine, littéralement « moteur de calcul de médias ») est une unité de calcul de type SIMD(Single Instruction on Multiple Data), accélérant les calculs} pour la partie Android. En plus de ces technologies, les ordinateurs classiques nous permettent d'utiliser des technologies comme SSE\footnote{Streaming SIMD Extensions, généralement abrégé SSE, est un jeu de 70 instructions supplémentaires pour microprocesseurs x86, le fonctionnement est de type SIMD.}, AVX\footnote{Advanced Vector Extensions, est une extension  des instructions SSE et s'appliquent sur des registres deux fois plus grand.}, ou encore CUDA\footnote{CUDA (Compute Unified Device Architecture) est une technologie de GPGPU (General-Purpose Computing on Graphics Processing Units), c'est-à-dire qu'un processeur graphique (GPU) est utilisé pour exécuter des calculs généraux habituellement exécutés par le processeur central (CPU).}.\\

\paragraph{L'estimation des performances énergétiques \\}

	Le but est de tester la consommation énergetique du parallélisme sur Android et sur PC avec les différentes technologies exploitables. \\

	Nos tests consistent à exécuter des algorithmes où le parallélisme s'applique de façon optimale. Pour ce, des algorithmes où le parallélisme est maximal serait optimale, c'est-à-dire où chaque processeurs travailleraient sur des tailles de données équivalentes (cf : Non Fonctionnelle).
